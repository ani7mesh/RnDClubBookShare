<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ISBN Scanner App</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script src="https://unpkg.com/quagga@0.12.1/dist/quagga.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 1em;
      background: #fefefe;
      text-align: center;
    }
    video, canvas {
      width: 100%;
      max-height: 50vh;
      object-fit: contain;
      border-radius: 8px;
    }
    button, input[type="file"], input[type="text"] {
      margin: 0.5em;
      padding: 0.6em 1.2em;
      font-size: 1em;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }
    input[type="text"] {
      background: white;
      color: black;
      border: 2px solid #007bff;
      width: 200px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    textarea {
      width: 95%;
      height: 100px;
      margin-top: 1em;
      font-size: 1em;
    }
    #zoomControl {
      width: 90%;
      display: none;
      margin-top: 1em;
    }
    #status {
      margin-top: 0.8em;
      font-weight: bold;
    }
    #spinner {
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #manualInputDiv {
      display: none;
      margin: 1em 0;
      padding: 1em;
      border: 2px solid #007bff;
      border-radius: 8px;
      background: #f8f9fa;
    }
    #manualResult {
      margin-top: 0.5em;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <h2>ISBN Scanner üìö</h2>
  <!-- Video element for camera feed -->
  <video id="video" autoplay muted playsinline></video>
  <!-- Zoom control slider, hidden by default -->
  <input type="range" id="zoomControl" min="1" max="5" step="0.1" value="1" />

  <div>
    <!-- Main action buttons for image capture and manual upload -->
    <button onclick="captureImage()">Capture</button>
    <button onclick="toggleManualInput()">Manual ISBN Entry</button>
    <button onclick="manualUpload()">Upload Image</button>
    <button onclick="clearResults()">Clear Results</button>
  </div>

  <!-- Manual ISBN input section (hidden by default) -->
  <div id="manualInputDiv">
    <h3>Enter ISBN Manually</h3>
    <input type="text" id="manualIsbnInput" placeholder="Enter 13-digit ISBN..." maxlength="13" />
    <button onclick="submitManualIsbn()">Submit</button>
    <button onclick="toggleManualInput()">Cancel</button>
    <div id="manualResult"></div>
  </div>

  <!-- Status display area -->
  <p id="status">Initializing...</p>

  <!-- Text area to display detected ISBNs and book information -->
  <textarea id="isbnText" placeholder="Detected ISBNs..."></textarea>
  <br />
  <!-- Email button to send results -->
  <button onclick="sendEmail()">Send via Email</button>
  <!-- Hidden file input for manual image upload -->
  <input type="file" accept="image/*" id="imageInput" style="display:none" onchange="handleImageUpload(event)" />

  <!-- Hidden canvas for image processing -->
  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // DOM element references
    const video = document.getElementById("video");
    const zoomControl = document.getElementById("zoomControl");
    const isbnText = document.getElementById("isbnText");
    const canvas = document.getElementById("canvas");
    const imageInput = document.getElementById("imageInput");
    const manualInputDiv = document.getElementById("manualInputDiv");
    const manualIsbnInput = document.getElementById("manualIsbnInput");
    const manualResult = document.getElementById("manualResult");
    
    // Global state variables
    let videoTrack = null;  // Stores the active video track for camera control
    let isProcessing = false;  // Flag to prevent multiple simultaneous operations

    // Check if browser supports camera functionality
    function checkCameraSupport() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showStatus("‚ùå Camera not supported in this browser.", true);
        return false;
      }
      
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        showStatus("‚ùå Camera requires HTTPS or localhost.", true);
        return false;
      }
      
      return true;
    }

    // Debug and enumerate available camera devices
    async function debugCameraDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        console.log('Available video devices:', videoDevices);
        
        if (videoDevices.length === 0) {
          showStatus("‚ùå No cameras detected on this device.", true);
          return false;
        }
        
        showStatus(`üì∑ Found ${videoDevices.length} camera(s). Initializing...`);
        return true;
      } catch (error) {
        console.error('Device enumeration failed:', error);
        showStatus("‚ùå Unable to detect cameras.", true);
        return false;
      }
    }

    // Initialize camera and set up video stream with comprehensive error handling
    async function initCamera() {
      // Check browser support first
      if (!checkCameraSupport()) return;
      
      // Check for available camera devices
      const hasCamera = await debugCameraDevices();
      if (!hasCamera) return;

      try {
        showStatus("Requesting camera permission...", false, true);
        
        // Request camera access with optimal settings for barcode scanning
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",  // Use rear camera if available
            width: { ideal: 1280 },     // High resolution for better scanning
            height: { ideal: 720 }
          } 
        });
        
        video.srcObject = stream;  // Assign stream to video element
        videoTrack = stream.getVideoTracks()[0];  // Get the video track for controls

        // Wait for video metadata to load before proceeding
        await new Promise((resolve) => {
          video.onloadedmetadata = resolve;
        });

        // Check if camera supports zoom functionality
        const capabilities = videoTrack.getCapabilities();
        if (capabilities.zoom) {
          // Configure zoom control with camera's capabilities
          zoomControl.min = capabilities.zoom.min;
          zoomControl.max = capabilities.zoom.max;
          zoomControl.step = capabilities.zoom.step || 0.1;
          zoomControl.value = capabilities.zoom.min;
          zoomControl.style.display = "block";  // Show zoom control
          
          // Apply zoom changes when user moves slider
          zoomControl.oninput = () => {
            videoTrack.applyConstraints({ advanced: [{ zoom: parseFloat(zoomControl.value) }] });
          };
        }

        showStatus("‚úÖ Camera ready. Scan a barcode or capture.");
        initBarcodeScanner();  // Start barcode scanning
        
      } catch (error) {
        console.error("Camera initialization error:", error);
        
        // Handle specific error types with user-friendly messages
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          showStatus("‚ùå No camera found. Please connect a camera.", true);
        } else if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          showStatus("‚ùå Camera in use by another application.", true);
        } else if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          showStatus("‚ùå Camera permission denied. Please allow camera access.", true);
        } else if (error.name === "OverconstrainedError" || error.name === "ConstraintNotSatisfiedError") {
          showStatus("‚ùå Camera constraints not supported. Trying fallback...", true);
          
          // Try with basic constraints as fallback
          try {
            const basicStream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = basicStream;
            videoTrack = basicStream.getVideoTracks()[0];
            showStatus("‚úÖ Camera ready with basic settings.");
            initBarcodeScanner();
          } catch (fallbackError) {
            showStatus("‚ùå Camera not available.", true);
          }
        } else {
          showStatus(`‚ùå Camera error: ${error.message}`, true);
        }
      }
    }

    // Initialize QuaggaJS barcode scanner for real-time detection
    function initBarcodeScanner() {
      Quagga.init({
        inputStream: {
          name: "Live",
          type: "LiveStream",
          target: video,  // Use video element as input
        },
        decoder: {
          readers: ["ean_reader"]  // Use EAN reader for ISBN barcodes
        }
      }, err => {
        if (err) {
          console.error('Barcode scanner initialization failed:', err);
          showStatus("‚ö†Ô∏è Barcode scanner failed to start. Use capture or manual entry.", true);
          return;
        }
        Quagga.start();  // Begin scanning
      });

      // Handle barcode detection events
      Quagga.onDetected(data => {
        if (isProcessing) return;  // Prevent processing if already busy
        const code = data.codeResult.code;  // Extract barcode value
        
        // Validate that detected code is a valid ISBN-13 (starts with 978 or 979, 13 digits total)
        if (/^97\d{11}$/.test(code)) {
          isProcessing = true;  // Set processing flag
          setButtonsState(true);  // Disable all buttons
          Quagga.stop();  // Temporarily stop scanner
          
          // Process the detected ISBN and re-enable scanner when done
          fetchAllSources(code).finally(() => {
            isProcessing = false;
            setButtonsState(false);
            Quagga.start();
          });
          showStatus(`üìñ ISBN Detected via Barcode: ${code}`);
        }
      });
    }

    // Manage button states during processing to prevent multiple operations
    function setButtonsState(disabled) {
      const captureBtn = document.querySelector('button[onclick="captureImage()"]');
      const manualEntryBtn = document.querySelector('button[onclick="toggleManualInput()"]');
      const uploadBtn = document.querySelector('button[onclick="manualUpload()"]');
      const emailBtn = document.querySelector('button[onclick="sendEmail()"]');
      const clearBtn = document.querySelector('button[onclick="clearResults()"]');
      
      // Enable/disable all interactive buttons
      if (captureBtn) captureBtn.disabled = disabled;
      if (manualEntryBtn) manualEntryBtn.disabled = disabled;
      if (uploadBtn) uploadBtn.disabled = disabled;
      if (emailBtn) emailBtn.disabled = disabled;
      if (clearBtn) clearBtn.disabled = disabled;
    }

    // Toggle manual ISBN input section visibility
    function toggleManualInput() {
      const isVisible = manualInputDiv.style.display !== "none";
      manualInputDiv.style.display = isVisible ? "none" : "block";
      
      if (!isVisible) {
        // Focus on input when showing
        manualIsbnInput.focus();
        manualResult.innerHTML = "";  // Clear previous results
        manualIsbnInput.value = "";   // Clear input field
      }
    }

    // Validate and submit manually entered ISBN
    function submitManualIsbn() {
      const isbn = manualIsbnInput.value.trim().replace(/[^\d]/g, ''); // Remove non-digits
      
      // Clear previous result
      manualResult.innerHTML = "";
      
      // Validate ISBN format
      if (!isbn) {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Please enter an ISBN</span>';
        return;
      }
      
      if (!/^97[89]\d{10}$/.test(isbn)) {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Invalid ISBN format. Must be 13 digits starting with 978 or 979</span>';
        return;
      }
      
      // Check if ISBN already exists
      if (isbnText.value.includes(isbn)) {
        manualResult.innerHTML = '<span style="color: orange;">‚ö†Ô∏è ISBN already in results</span>';
        return;
      }
      
      // Process the ISBN
      manualResult.innerHTML = '<span style="color: blue;">üîç Looking up book information...</span>';
      
      fetchAllSources(isbn).then(() => {
        manualResult.innerHTML = '<span style="color: green;">‚úÖ Book information added to results</span>';
        // Clear input after successful submission
        manualIsbnInput.value = "";
      }).catch(error => {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Error looking up book information</span>';
      });
    }

    // Capture current video frame and perform OCR to detect ISBNs
    function captureImage() {
      if (isProcessing) return;  // Exit if already processing
      
      isProcessing = true;  // Set processing flag
      setButtonsState(true);  // Disable all buttons
      Quagga.stop();  // Stop barcode scanner
      showStatus("üì∑ Scanning image via OCR...", false, true);  // Show loading status

      // Set canvas dimensions to match video
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      
      // Draw current video frame to canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Perform OCR on captured image
      Tesseract.recognize(canvas, 'eng').then(({  { text } }) => {
        // Extract ISBN numbers from OCR text
        const matches = extractISBNs(text);
        if (!matches.length) {
          showStatus("‚ùå No valid ISBN-13 found in image.");
          return;
        }

        showStatus(`üîç Found ${matches.length} ISBN(s). Processing...`);

        // Process each found ISBN
        let remaining = matches.length;
        matches.forEach(isbn => {
          fetchAllSources(isbn).finally(() => {
            remaining--;
            // Re-enable interface when all ISBNs are processed
            if (remaining === 0) {
              showStatus(`‚úÖ Processed ${matches.length} ISBN(s).`);
              isProcessing = false;
              setButtonsState(false);
              Quagga.start();
            }
          });
        });
      }).catch(err => {
        // Handle OCR errors
        console.error('OCR failed:', err);
        showStatus("‚ùå OCR failed. Try capturing again.", true);
      }).finally(() => {
        // Ensure cleanup happens even if OCR fails
        if (isProcessing) {
          isProcessing = false;
          setButtonsState(false);
          Quagga.start();
        }
      });
    }

    // Enhanced ISBN extraction with comprehensive validation
    function extractISBNs(text) {
      // More comprehensive ISBN-13 extraction pattern (handles various formats)
      const isbnPattern = /(?:ISBN[-:\s]*)?(?:97[89][-\s]?\d{1}[-\s]?\d{3}[-\s]?\d{5}[-\s]?\d{1}|\b97[89]\d{10}\b)/gi;
      const matches = text.match(isbnPattern) || [];
      
      // Clean and validate extracted ISBNs
      return [...new Set(matches.map(isbn => 
        isbn.replace(/[^\d]/g, '') // Remove all non-digits
      ).filter(isbn => 
        /^97[89]\d{10}$/.test(isbn) // Validate 13-digit format starting with 978/979
      ))];
    }

    // Fetch book information from APIs with retry logic and exponential backoff
    async function fetchWithRetry(url, maxRetries = 2) {
      // Attempt API call with exponential backoff retry
      for (let i = 0; i <= maxRetries; i++) {
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return response;
        } catch (error) {
          if (i === maxRetries) throw error;  // Final attempt failed
          // Wait before retry (1s, 2s, etc.)
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    // Query multiple book databases for ISBN information with comprehensive error handling
    function fetchAllSources(isbn) {
      return (async () => {
        try {
          // Check if ISBN already exists in results
          const existing = isbnText.value;
          if (existing.includes(isbn)) return;

          const results = [`${isbn}`];  // Start with ISBN number

          // Google Books API with error handling
          try {
            const gBook = await fetchWithRetry(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`)
              .then(r => r.json());
            const gTitle = gBook.items?.[0]?.volumeInfo?.title;
            if (gTitle) results.push(`GoogleBooks: ${gTitle}`);
          } catch (e) {
            console.warn(`Google Books API failed for ${isbn}:`, e);
          }

          // OpenLibrary API with error handling
          try {
            const openLib = await fetchWithRetry(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`)
              .then(r => r.json());
            const oTitle = openLib[`ISBN:${isbn}`]?.title;
            if (oTitle) results.push(`OpenLibrary: ${oTitle}`);
          } catch (e) {
            console.warn(`OpenLibrary API failed for ${isbn}:`, e);
          }

          // LibraryThing API with error handling
          try {
            const libThing = await fetchWithRetry(`https://www.librarything.com/api/thingTitle/${isbn}`)
              .then(r => r.text());
            if (libThing && !libThing.includes('No data')) {
              results.push(`LibraryThing: ${libThing.trim()}`);
            }
          } catch (e) {
            console.warn(`LibraryThing API failed for ${isbn}:`, e);
          }

          // If no book info found, mark for rescanning
          if (results.length === 1) results.push("RESCAN");
          
          // Add results to textarea
          appendISBN(results.join(" | "));
        } catch (error) {
          console.error(`Error processing ISBN ${isbn}:`, error);
          showStatus(`‚ùå Error processing ISBN: ${isbn}`, true);
        }
      })();
    }

    // Add ISBN entry to results textarea
    function appendISBN(entry) {
      // Add new entry with line break if textarea has content
      isbnText.value += (isbnText.value ? "\n" : "") + entry;
    }

    // Send results via email using mailto protocol
    function sendEmail() {
      // Filter out "RESCAN" entries for cleaner email
      const cleanLines = isbnText.value.split("\n").filter(line => !line.includes("RESCAN"));
      if (!cleanLines.length) return alert("‚ùå Nothing to send.");
      
      // Create email with subject and body containing ISBN results
      const mail = `mailto:?subject=Scanned ISBNs&body=${encodeURIComponent(cleanLines.join("\n"))}`;
      window.location.href = mail;  // Open default email client
    }

    // Trigger hidden file input for manual image upload
    function manualUpload() {
      imageInput.click();
    }

    // Clear all results from textarea
    function clearResults() {
      isbnText.value = "";  // Clear textarea content
      manualResult.innerHTML = "";  // Clear manual input result
      showStatus("üóëÔ∏è Results cleared.");
    }

    // Handle manually uploaded image files
    function handleImageUpload(event) {
      const file = event.target.files[0];  // Get selected file
      if (!file) return;
      
      setButtonsState(true);  // Disable buttons during processing
      showStatus("üì§ Processing uploaded image...", false, true);

      // Perform OCR on uploaded file
      Tesseract.recognize(file, 'eng').then(({  { text } }) => {
        const matches = extractISBNs(text);  // Extract ISBNs from OCR text
        if (!matches.length) {
          showStatus("‚ùå No valid ISBN-13 found in uploaded image.");
          return;
        }
        
        showStatus(`üîç Found ${matches.length} ISBN(s) in upload. Processing...`);
        
        // Process each found ISBN
        let remaining = matches.length;
        matches.forEach(isbn => {
          fetchAllSources(isbn).finally(() => {
            remaining--;
            if (remaining === 0) {
              showStatus(`‚úÖ Processed ${matches.length} ISBN(s) from upload.`);
              setButtonsState(false);  // Re-enable buttons when done
            }
          });
        });
      }).catch(err => {
        console.error('Upload OCR failed:', err);
        showStatus("‚ùå OCR failed on uploaded image.", true);
      }).finally(() => {
        setButtonsState(false);  // Ensure buttons are re-enabled
        // Clear file input for next use
        imageInput.value = '';
      });
    }

    // Display status messages to user with optional loading spinner
    function showStatus(msg, error = false, showSpinner = false) {
      const el = document.getElementById("status");
      // Show message with optional spinner animation
      el.innerHTML = showSpinner ? `${msg} <span id="spinner">‚è≥</span>` : msg;
      el.style.color = error ? "red" : "green";  // Color code status (red for errors, green for success)
    }

    // Clean up camera resources to prevent memory leaks
    function stopCamera() {
      // Stop video track if active
      if (videoTrack) {
        videoTrack.stop();
        videoTrack = null;
      }
      // Stop all tracks in video stream
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
    }

    // Add Enter key support for manual ISBN input
    manualIsbnInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        event.preventDefault();
        submitManualIsbn();
      }
    });

    // Only allow digits in manual ISBN input
    manualIsbnInput.addEventListener('input', function(event) {
      // Remove any non-digit characters
      this.value = this.value.replace(/[^\d]/g, '');
      
      // Clear result when user types
      if (manualResult.innerHTML) {
        manualResult.innerHTML = "";
      }
    });

    // Initialize camera when page loads
    window.onload = () => {
      if (checkCameraSupport()) {
        initCamera();
      }
    };
    
    // Clean up camera resources when user leaves page
    window.addEventListener('beforeunload', stopCamera);
  </script>

</body>
</html>
