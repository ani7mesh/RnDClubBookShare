<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ISBN Scanner App</title>
  <!-- Tesseract for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <!-- Quagga for barcode decoding (used on single images/canvas frames) -->
  <script src="https://unpkg.com/quagga@0.12.1/dist/quagga.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 1em;
      background: #fefefe;
      text-align: center;
    }
    video, canvas {
      width: 100%;
      max-height: 50vh;
      object-fit: contain;
      border-radius: 8px;
    }
    button, input[type="file"], input[type="text"] {
      margin: 0.5em;
      padding: 0.6em 1.2em;
      font-size: 1em;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }
    input[type="text"] {
      background: white;
      color: black;
      border: 2px solid #007bff;
      width: 200px;
    }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    textarea {
      width: 95%;
      height: 100px;
      margin-top: 1em;
      font-size: 1em;
    }
    #zoomControl {
      width: 90%;
      display: none;
      margin-top: 1em;
    }
    #status { margin-top: 0.8em; font-weight: bold; }
    #spinner { animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    #manualInputDiv {
      display: none;
      margin: 1em 0;
      padding: 1em;
      border: 2px solid #007bff;
      border-radius: 8px;
      background: #f8f9fa;
    }
    #manualResult { margin-top: 0.5em; font-weight: bold; }
  </style>
</head>
<body>

  <h2>ISBN Scanner üìö</h2>

  <!-- Video element used for a single getUserMedia stream (no Quagga LiveStream) -->
  <video id="video" autoplay muted playsinline></video>

  <!-- Zoom control slider (shown only if device supports zoom) -->
  <input type="range" id="zoomControl" min="1" max="5" step="0.1" value="1" />

  <div>
    <!-- Buttons use IDs; handlers are bound via addEventListener (CSP friendly) -->
    <button id="captureBtn">Capture</button>
    <button id="manualEntryBtn">Manual ISBN Entry</button>
    <button id="uploadBtn">Upload Image</button>
    <button id="clearBtn">Clear Results</button>
  </div>

  <!-- Manual ISBN input (toggle visible) -->
  <div id="manualInputDiv">
    <h3>Enter ISBN Manually</h3>
    <input type="text" id="manualIsbnInput" placeholder="Enter 13-digit ISBN..." maxlength="13" />
    <button id="manualSubmitBtn">Submit</button>
    <button id="manualCancelBtn">Cancel</button>
    <div id="manualResult"></div>
  </div>

  <p id="status">Initializing...</p>

  <textarea id="isbnText" placeholder="Detected ISBNs..."></textarea>
  <br />
  <button id="sendBtn">Send via Email</button>

  <input type="file" accept="image/*" id="imageInput" style="display:none" />

  <!-- Hidden canvas to grab frames for barcode/OCR -->
  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // Element references
    const video = document.getElementById("video");
    const zoomControl = document.getElementById("zoomControl");
    const isbnText = document.getElementById("isbnText");
    const canvas = document.getElementById("canvas");
    const imageInput = document.getElementById("imageInput");

    const captureBtn = document.getElementById("captureBtn");
    const manualEntryBtn = document.getElementById("manualEntryBtn");
    const uploadBtn = document.getElementById("uploadBtn");
    const clearBtn = document.getElementById("clearBtn");
    const sendBtn = document.getElementById("sendBtn");

    const manualInputDiv = document.getElementById("manualInputDiv");
    const manualIsbnInput = document.getElementById("manualIsbnInput");
    const manualSubmitBtn = document.getElementById("manualSubmitBtn");
    const manualCancelBtn = document.getElementById("manualCancelBtn");
    const manualResult = document.getElementById("manualResult");

    // State
    let videoTrack = null;
    let isProcessing = false;

    // CSP-safe event bindings
    document.addEventListener("DOMContentLoaded", () => {
      captureBtn.addEventListener("click", captureImage);
      manualEntryBtn.addEventListener("click", toggleManualInput);
      uploadBtn.addEventListener("click", () => imageInput.click());
      clearBtn.addEventListener("click", clearResults);
      sendBtn.addEventListener("click", sendEmail);
      manualSubmitBtn.addEventListener("click", submitManualIsbn);
      manualCancelBtn.addEventListener("click", toggleManualInput);
      manualIsbnInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") { e.preventDefault(); submitManualIsbn(); }
      });
      manualIsbnInput.addEventListener("input", function () {
        this.value = this.value.replace(/[^\d]/g, "");
        manualResult.innerHTML = "";
      });
      imageInput.addEventListener("change", handleImageUpload);

      // Initialize camera after bindings
      if (checkCameraSupport()) initCamera();
    });

    // Support checks (HTTPS + API)
    function checkCameraSupport() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showStatus("‚ùå Camera not supported in this browser.", true);
        return false;
      }
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        showStatus("‚ùå Camera requires HTTPS or localhost.", true);
        return false;
      }
      return true;
    }

    // Enumerate devices (optional diagnostics)
    async function debugCameraDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === "videoinput");
        if (videoDevices.length === 0) {
          showStatus("‚ùå No cameras detected on this device.", true);
          return false;
        }
        showStatus(`üì∑ Found ${videoDevices.length} camera(s). Initializing...`);
        return true;
      } catch (e) {
        console.error("Device enumeration failed:", e);
        showStatus("‚ùå Unable to detect cameras.", true);
        return false;
      }
    }

    // Initialize a single camera stream to <video>
    async function initCamera() {
      const hasCameras = await debugCameraDevices();
      if (!hasCameras) return;

      try {
        showStatus("Requesting camera permission...", false, true);
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];

        await new Promise(res => video.onloadedmetadata = res);

        const capabilities = videoTrack.getCapabilities?.() || {};
        if (capabilities.zoom) {
          zoomControl.min = capabilities.zoom.min;
          zoomControl.max = capabilities.zoom.max;
          zoomControl.step = capabilities.zoom.step || 0.1;
          zoomControl.value = capabilities.zoom.min;
          zoomControl.style.display = "block";
          zoomControl.oninput = () => {
            videoTrack.applyConstraints({ advanced: [{ zoom: parseFloat(zoomControl.value) }] });
          };
        }

        showStatus("‚úÖ Camera ready. Use Capture or Upload.");
      } catch (error) {
        console.error("Camera initialization error:", error);
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          showStatus("‚ùå No camera found. Please connect a camera.", true);
        } else if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          showStatus("‚ùå Camera in use by another application.", true);
        } else if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          showStatus("‚ùå Camera permission denied. Please allow camera access.", true);
        } else if (error.name === "OverconstrainedError" || error.name === "ConstraintNotSatisfiedError") {
          showStatus("‚ùå Camera constraints not supported. Trying fallback...", true);
          try {
            const basicStream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = basicStream;
            videoTrack = basicStream.getVideoTracks()[0];
            showStatus("‚úÖ Camera ready with basic settings.");
          } catch {
            showStatus("‚ùå Camera not available.", true);
          }
        } else {
          showStatus(`‚ùå Camera error: ${error.message}`, true);
        }
      }
    }

    // Button state management
    function setButtonsState(disabled) {
      [captureBtn, manualEntryBtn, uploadBtn, clearBtn, sendBtn].forEach(b => { if (b) b.disabled = disabled; });
    }

    // Capture a frame and decode: try barcode via Quagga, then OCR fallback
    async function captureImage() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsState(true);
      showStatus("üì∑ Capturing frame and scanning...", false, true);

      try {
        // Draw the current video frame into canvas
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // Attempt barcode first using Quagga on this single image (no extra camera stream)
        const code = await decodeCanvasWithQuagga(canvas);
        if (code && /^97\d{11}$/.test(code)) {
          showStatus(`üìñ Barcode detected: ${code}`);
          await fetchAllSources(code);
          return;
        }

        // Fallback to OCR if no barcode found
        showStatus("üî§ No barcode; running OCR...", false, true);
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng');
        const matches = extractISBNs(text);
        if (!matches.length) {
          showStatus("‚ùå No valid ISBN-13 found in image.");
          return;
        }
        showStatus(`üîç Found ${matches.length} ISBN(s). Processing...`);
        await Promise.all(matches.map(isbn => fetchAllSources(isbn)));
        showStatus(`‚úÖ Processed ${matches.length} ISBN(s).`);
      } catch (e) {
        console.error("Capture error:", e);
        showStatus("‚ùå Capture/scan failed. Try again.", true);
      } finally {
        isProcessing = false;
        setButtonsState(false);
      }
    }

    // Use Quagga.decodeSingle on canvas data URL
    function decodeCanvasWithQuagga(canvasEl) {
      return new Promise((resolve) => {
        try {
          const dataUrl = canvasEl.toDataURL("image/jpeg", 0.92);
          Quagga.decodeSingle({
            src: dataUrl,
            inputStream: { size: 800 },
            locate: true,
            decoder: { readers: ["ean_reader"] }
          }, function (result) {
            const code = result && result.codeResult && result.codeResult.code;
            resolve(code || null);
          });
        } catch {
          resolve(null);
        }
      });
    }

    // Enhanced ISBN extraction (13 digits starting 978/979; tolerate dashes/spaces)
    function extractISBNs(text) {
      const isbnPattern = /(?:ISBN[-:\s]*)?(?:97[89][-\s]?\d{1}[-\s]?\d{3}[-\s]?\d{5}[-\s]?\d{1}|\b97[89]\d{10}\b)/gi;
      const matches = text.match(isbnPattern) || [];
      return [...new Set(matches.map(s => s.replace(/[^\d]/g, '')).filter(s => /^97[89]\d{10}$/.test(s)))];
    }

    // Simple retry wrapper for fetches
    async function fetchWithRetry(url, maxRetries = 2) {
      for (let i = 0; i <= maxRetries; i++) {
        try {
          const r = await fetch(url);
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r;
        } catch (e) {
          if (i === maxRetries) throw e;
          await new Promise(res => setTimeout(res, 1000 * (i + 1)));
        }
      }
    }

    // Query multiple sources for a given ISBN
    function fetchAllSources(isbn) {
      return (async () => {
        const existing = isbnText.value;
        if (existing.includes(isbn)) return;

        const results = [`${isbn}`];

        try {
          const gBook = await fetchWithRetry(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`).then(r => r.json());
          const gTitle = gBook.items?.[0]?.volumeInfo?.title;
          if (gTitle) results.push(`GoogleBooks: ${gTitle}`);
        } catch (e) { console.warn("Google Books failed:", e); }

        try {
          const openLib = await fetchWithRetry(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`).then(r => r.json());
          const oTitle = openLib[`ISBN:${isbn}`]?.title;
          if (oTitle) results.push(`OpenLibrary: ${oTitle}`);
        } catch (e) { console.warn("OpenLibrary failed:", e); }

        try {
          const libThing = await fetchWithRetry(`https://www.librarything.com/api/thingTitle/${isbn}`).then(r => r.text());
          if (libThing && !libThing.includes('No data')) results.push(`LibraryThing: ${libThing.trim()}`);
        } catch (e) { console.warn("LibraryThing failed:", e); }

        if (results.length === 1) results.push("RESCAN");
        appendISBN(results.join(" | "));
      })();
    }

    // Append to textarea
    function appendISBN(entry) {
      isbnText.value += (isbnText.value ? "\n" : "") + entry;
    }

    // Mail results
    function sendEmail() {
      const cleanLines = isbnText.value.split("\n").filter(line => !line.includes("RESCAN"));
      if (!cleanLines.length) return alert("‚ùå Nothing to send.");
      const mail = `mailto:?subject=Scanned ISBNs&body=${encodeURIComponent(cleanLines.join("\n"))}`;
      window.location.href = mail;
    }

    // Toggle manual input UI
    function toggleManualInput() {
      const nowVisible = manualInputDiv.style.display !== "block";
      manualInputDiv.style.display = nowVisible ? "block" : "none";
      if (nowVisible) {
        manualIsbnInput.value = "";
        manualResult.innerHTML = "";
        manualIsbnInput.focus();
      }
    }

    // Manual ISBN submit
    function submitManualIsbn() {
      const isbn = manualIsbnInput.value.trim().replace(/[^\d]/g, '');
      manualResult.innerHTML = "";

      if (!isbn) {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Please enter an ISBN</span>';
        return;
      }
      if (!/^97[89]\d{10}$/.test(isbn)) {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Invalid ISBN format. Must be 13 digits starting with 978 or 979</span>';
        return;
      }
      if (isbnText.value.includes(isbn)) {
        manualResult.innerHTML = '<span style="color: orange;">‚ö†Ô∏è ISBN already in results</span>';
        return;
      }

      manualResult.innerHTML = '<span style="color: blue;">üîç Looking up book information...</span>';
      fetchAllSources(isbn).then(() => {
        manualResult.innerHTML = '<span style="color: green;">‚úÖ Book information added to results</span>';
        manualIsbnInput.value = "";
      }).catch(() => {
        manualResult.innerHTML = '<span style="color: red;">‚ùå Error looking up book information</span>';
      });
    }

    // Upload image handler: try barcode via Quagga first, OCR fallback
    async function handleImageUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      setButtonsState(true);
      showStatus("üì§ Processing uploaded image...", false, true);

      try {
        // Draw image file into canvas
        const img = new Image();
        img.onload = async () => {
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);

          // Try barcode
          const code = await decodeCanvasWithQuagga(canvas);
          if (code && /^97\d{11}$/.test(code)) {
            showStatus(`üìñ Barcode detected from upload: ${code}`);
            await fetchAllSources(code);
          } else {
            // OCR fallback
            showStatus("üî§ No barcode in upload; running OCR...", false, true);
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng');
            const matches = extractISBNs(text);
            if (!matches.length) {
              showStatus("‚ùå No valid ISBN-13 found in uploaded image.");
            } else {
              showStatus(`üîç Found ${matches.length} ISBN(s) in upload. Processing...`);
              await Promise.all(matches.map(isbn => fetchAllSources(isbn)));
              showStatus(`‚úÖ Processed ${matches.length} ISBN(s) from upload.`);
            }
          }
          setButtonsState(false);
          imageInput.value = "";
        };
        img.onerror = () => {
          showStatus("‚ùå Could not read image file.", true);
          setButtonsState(false);
          imageInput.value = "";
        };
        img.src = URL.createObjectURL(file);
      } catch (err) {
        console.error("Upload processing failed:", err);
        showStatus("‚ùå OCR/scan failed on uploaded image.", true);
        setButtonsState(false);
        imageInput.value = "";
      }
    }

    // Status helper (with optional spinner)
    function showStatus(msg, error = false, showSpinner = false) {
      const el = document.getElementById("status");
      el.innerHTML = showSpinner ? `${msg} <span id="spinner">‚è≥</span>` : msg;
      el.style.color = error ? "red" : "green";
    }

    // Cleanup on unload
    function stopCamera() {
      if (videoTrack) {
        videoTrack.stop();
        videoTrack = null;
      }
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
    }
    window.addEventListener('beforeunload', stopCamera);
  </script>
</body>
</html>
